/*
 * File: composeCPPPrediction.c
 *
 * MATLAB Coder version            : 2.6
 * C/C++ source code generated on  : 16-May-2014 12:41:07
 */

/* Include files */
#include "rt_nonfinite.h"
#include "composeCPPPrediction.h"
#include "composeUMatrix.h"

/* Function Definitions */

/*
 * This function is solely to make C code generation more consize.
 * Arguments    : const double state[9]
 *                const double inputs[6]
 *                const double parameters[8]
 *                double f_vec[9]
 *                double A_matrix[81]
 *                double U_matrix[54]
 * Return Type  : void
 */
void composeCPPPrediction(const double state[9], const double inputs[6], const
  double parameters[8], double f_vec[9], double A_matrix[81], double U_matrix[54])
{
  double t3;
  double t6;
  double t11;
  double t12;
  double t13;
  double t14;
  double t18;
  double t21;
  double t2;
  double t4;
  double x[81];

  /* % composePrediction.m */
  /* COMPOSEFFUNCTION */
  /*     F_VEC = COMPOSEFFUNCTION(IN1,IN2,IN3) */
  /*     This function was generated by the Symbolic Math Toolbox version 6.0. */
  /*     16-May-2014 12:41:04 */
  t3 = state[4] * state[6] * 2.0 - state[5] * state[7] * 2.0;
  t6 = state[4] * state[5] * 2.0 + state[6] * state[7] * 2.0;
  t11 = ((state[4] * state[4] - state[5] * state[5]) - state[6] * state[6]) +
    state[7] * state[7];
  t12 = fabs(inputs[0]);
  t13 = fabs(inputs[1]);
  t14 = fabs(inputs[2]);
  t18 = (t12 * t12 + t13 * t13) + t14 * t14;
  t12 = parameters[5] * sqrt(t18) * 0.5;
  t21 = sin(t12);
  t13 = 1.0 / sqrt(t18);
  t12 = cos(t12);
  f_vec[0] = ((state[0] - parameters[5] * t3 * state[1]) + parameters[5] * t6 *
              state[2]) + parameters[5] * t11 * state[3];
  f_vec[1] = state[1] + parameters[5] * (parameters[1] * t3 - parameters[4] *
    state[1]);
  f_vec[2] = state[2] - parameters[5] * (parameters[1] * t6 + parameters[4] *
    state[2]);
  f_vec[3] = state[3] + parameters[5] * (inputs[5] - parameters[1] * t11);
  f_vec[4] = ((state[4] * t12 - state[5] * t21 * t13 * inputs[0]) - state[6] *
              t21 * t13 * inputs[1]) - state[7] * t21 * t13 * inputs[2];
  f_vec[5] = ((state[5] * t12 + state[4] * t21 * t13 * inputs[0]) + state[6] *
              t21 * t13 * inputs[2]) - state[7] * t21 * t13 * inputs[1];
  f_vec[6] = ((state[6] * t12 + state[4] * t21 * t13 * inputs[1]) - state[5] *
              t21 * t13 * inputs[2]) + state[7] * t21 * t13 * inputs[0];
  f_vec[7] = ((state[7] * t12 + state[4] * t21 * t13 * inputs[2]) + state[5] *
              t21 * t13 * inputs[1]) - state[6] * t21 * t13 * inputs[0];
  f_vec[8] = state[8];

  /* COMPOSEAMATRIX */
  /*     A_SYM = COMPOSEAMATRIX(IN1,IN2,IN3) */
  /*     This function was generated by the Symbolic Math Toolbox version 6.0. */
  /*     16-May-2014 12:41:05 */
  t2 = -parameters[5] * parameters[4] + 1.0;
  t3 = parameters[5] * parameters[1] * state[4] * 2.0;
  t4 = parameters[5] * parameters[1] * state[6] * 2.0;
  t12 = fabs(inputs[0]);
  t6 = fabs(inputs[1]);
  t13 = fabs(inputs[2]);
  t11 = (t12 * t12 + t6 * t6) + t13 * t13;
  t13 = parameters[5] * sqrt(t11) * 0.5;
  t14 = sin(t13);
  t11 = 1.0 / sqrt(t11);
  t12 = cos(t13);
  t21 = t14 * t11 * inputs[2];
  t18 = t14 * t11 * inputs[0];
  t13 = t14 * t11 * inputs[1];
  x[0] = 1.0;
  x[1] = 0.0;
  x[2] = 0.0;
  x[3] = 0.0;
  x[4] = 0.0;
  x[5] = 0.0;
  x[6] = 0.0;
  x[7] = 0.0;
  x[8] = 0.0;
  x[9] = parameters[5] * (state[4] * state[6] - state[5] * state[7]) * -2.0;
  x[10] = t2;
  x[11] = 0.0;
  x[12] = 0.0;
  x[13] = 0.0;
  x[14] = 0.0;
  x[15] = 0.0;
  x[16] = 0.0;
  x[17] = 0.0;
  x[18] = parameters[5] * (state[4] * state[5] * 2.0 + state[6] * state[7] * 2.0);
  x[19] = 0.0;
  x[20] = t2;
  x[21] = 0.0;
  x[22] = 0.0;
  x[23] = 0.0;
  x[24] = 0.0;
  x[25] = 0.0;
  x[26] = 0.0;
  x[27] = parameters[5] * (((state[4] * state[4] - state[5] * state[5]) - state
    [6] * state[6]) + state[7] * state[7]);
  x[28] = 0.0;
  x[29] = 0.0;
  x[30] = 1.0;
  x[31] = 0.0;
  x[32] = 0.0;
  x[33] = 0.0;
  x[34] = 0.0;
  x[35] = 0.0;
  x[36] = parameters[5] * ((-state[6] * state[1] + state[5] * state[2]) + state
    [4] * state[3]) * 2.0;
  x[37] = t4;
  x[38] = parameters[5] * parameters[1] * state[5] * -2.0;
  x[39] = -t3;
  x[40] = t12;
  x[41] = t18;
  x[42] = t13;
  x[43] = t21;
  x[44] = 0.0;
  x[45] = parameters[5] * ((state[7] * state[1] + state[4] * state[2]) - state[5]
    * state[3]) * 2.0;
  x[46] = parameters[5] * parameters[1] * state[7] * -2.0;
  x[47] = -t3;
  x[48] = parameters[5] * parameters[1] * state[5] * 2.0;
  x[49] = -t14 * t11 * inputs[0];
  x[50] = t12;
  x[51] = -t21;
  x[52] = t13;
  x[53] = 0.0;
  x[54] = parameters[5] * ((state[4] * state[1] - state[7] * state[2]) + state[6]
    * state[3]) * -2.0;
  x[55] = t3;
  x[56] = parameters[5] * parameters[1] * state[7] * -2.0;
  x[57] = t4;
  x[58] = -t14 * t11 * inputs[1];
  x[59] = t21;
  x[60] = t12;
  x[61] = -t18;
  x[62] = 0.0;
  x[63] = parameters[5] * ((state[5] * state[1] + state[6] * state[2]) + state[7]
    * state[3]) * 2.0;
  x[64] = parameters[5] * parameters[1] * state[5] * -2.0;
  x[65] = -t4;
  x[66] = parameters[5] * parameters[1] * state[7] * -2.0;
  x[67] = -t14 * t11 * inputs[2];
  x[68] = -t14 * t11 * inputs[1];
  x[69] = t18;
  x[70] = t12;
  x[71] = 0.0;
  x[72] = 0.0;
  x[73] = 0.0;
  x[74] = 0.0;
  x[75] = 0.0;
  x[76] = 0.0;
  x[77] = 0.0;
  x[78] = 0.0;
  x[79] = 0.0;
  x[80] = 1.0;
  memcpy(&A_matrix[0], &x[0], 81U * sizeof(double));
  composeUMatrix(state, inputs, parameters, U_matrix);
}

/*
 * File trailer for composeCPPPrediction.c
 *
 * [EOF]
 */
